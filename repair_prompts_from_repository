#!/usr/bin/env python3
"""
Fix Prompts System - SoluciÃ³n completa para Railway
Resuelve todos los problemas identificados en el sistema de prompts multi-tenant

Problemas que resuelve:
1. Migra prompts correctos de custom_prompts.json a PostgreSQL
2. Arregla foreign key constraints en prompt_versions
3. Repara funciÃ³n SQL ambigua repair_prompts_from_repository
4. Sincroniza prompts por defecto con los del repositorio
"""

import os
import sys
import json
import logging
import psycopg2
from psycopg2.extras import RealDictCursor
from datetime import datetime
from typing import Dict, List, Any, Optional

logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s [%(levelname)s] %(message)s'
)
logger = logging.getLogger(__name__)

class PromptsSystemFixer:
    """Reparador completo del sistema de prompts"""
    
    def __init__(self, db_connection_string: str = None):
        self.db_connection_string = db_connection_string or os.getenv('DATABASE_URL')
        if not self.db_connection_string:
            raise ValueError("DATABASE_URL no encontrada en variables de entorno")
    
    def fix_all_issues(self) -> Dict[str, Any]:
        """Ejecuta todas las reparaciones necesarias"""
        results = {
            "start_time": datetime.utcnow().isoformat(),
            "steps_completed": [],
            "errors": [],
            "success": False
        }
        
        try:
            logger.info("ğŸš€ Iniciando reparaciÃ³n completa del sistema de prompts")
            
            # Paso 1: Reparar funciÃ³n SQL ambigua
            if self._fix_sql_functions():
                results["steps_completed"].append("sql_functions_fixed")
                logger.info("âœ… Paso 1: Funciones SQL reparadas")
            else:
                results["errors"].append("Error reparando funciones SQL")
                return results
            
            # Paso 2: Arreglar foreign key constraints
            if self._fix_foreign_key_constraints():
                results["steps_completed"].append("foreign_keys_fixed")
                logger.info("âœ… Paso 2: Foreign key constraints arreglados")
            else:
                results["errors"].append("Error arreglando foreign keys")
                return results
            
            # Paso 3: Migrar prompts de custom_prompts.json
            if self._migrate_correct_prompts():
                results["steps_completed"].append("prompts_migrated")
                logger.info("âœ… Paso 3: Prompts correctos migrados")
            else:
                results["errors"].append("Error migrando prompts")
                return results
            
            # Paso 4: Validar sistema
            if self._validate_system():
                results["steps_completed"].append("system_validated")
                logger.info("âœ… Paso 4: Sistema validado")
                results["success"] = True
            else:
                results["errors"].append("Error en validaciÃ³n final")
            
            results["end_time"] = datetime.utcnow().isoformat()
            logger.info("ğŸ‰ ReparaciÃ³n completa exitosa")
            
        except Exception as e:
            logger.error(f"ğŸ’¥ Error crÃ­tico en reparaciÃ³n: {e}")
            results["errors"].append(f"Critical error: {str(e)}")
            results["end_time"] = datetime.utcnow().isoformat()
        
        return results
    
    def _fix_sql_functions(self) -> bool:
        """Repara las funciones SQL con problemas de ambigÃ¼edad"""
        logger.info("Reparando funciones SQL...")
        
        try:
            conn = psycopg2.connect(self.db_connection_string)
            
            with conn.cursor() as cursor:
                # Eliminar funciones problemÃ¡ticas
                cursor.execute("DROP FUNCTION IF EXISTS repair_prompts_from_repository(VARCHAR, VARCHAR, VARCHAR)")
                cursor.execute("DROP FUNCTION IF EXISTS create_prompt_version()")
                
                # Crear funciÃ³n repair_prompts_from_repository corregida
                repair_function_sql = """
                CREATE OR REPLACE FUNCTION repair_prompts_from_repository(
                    p_company_id VARCHAR(100) DEFAULT NULL,
                    p_agent_name VARCHAR(100) DEFAULT NULL,
                    p_repair_user VARCHAR(100) DEFAULT 'system_repair'
                ) RETURNS TABLE (
                    agent_name VARCHAR(100),
                    action VARCHAR(50),
                    success BOOLEAN,
                    message TEXT
                ) AS $$
                DECLARE
                    repair_count INTEGER := 0;
                BEGIN
                    -- Si se especifica un agente especÃ­fico
                    IF p_agent_name IS NOT NULL THEN
                        -- Verificar que existe en default_prompts (usando alias para evitar ambigÃ¼edad)
                        IF EXISTS (SELECT 1 FROM default_prompts dp WHERE dp.agent_name = p_agent_name) THEN
                            -- Insertar prompt personalizado desde default
                            INSERT INTO custom_prompts (company_id, agent_name, template, created_by, modified_by, notes)
                            SELECT 
                                p_company_id, 
                                dp.agent_name,
                                dp.template,
                                p_repair_user,
                                p_repair_user,
                                'Reparado desde repositorio'
                            FROM default_prompts dp
                            WHERE dp.agent_name = p_agent_name
                            ON CONFLICT (company_id, agent_name) DO UPDATE SET
                                template = EXCLUDED.template,
                                modified_by = EXCLUDED.modified_by,
                                modified_at = CURRENT_TIMESTAMP,
                                notes = EXCLUDED.notes;
                            
                            RETURN QUERY SELECT 
                                p_agent_name, 
                                'REPAIRED'::VARCHAR(50), 
                                true, 
                                'Prompt reparado exitosamente'::TEXT;
                        ELSE
                            RETURN QUERY SELECT 
                                p_agent_name, 
                                'NOT_FOUND'::VARCHAR(50), 
                                false, 
                                'Agente no encontrado en default_prompts'::TEXT;
                        END IF;
                    ELSE
                        -- Reparar todos los agentes para la empresa
                        INSERT INTO custom_prompts (company_id, agent_name, template, created_by, modified_by, notes)
                        SELECT 
                            p_company_id, 
                            dp.agent_name,
                            dp.template,
                            p_repair_user,
                            p_repair_user,
                            'ReparaciÃ³n masiva desde repositorio'
                        FROM default_prompts dp
                        ON CONFLICT (company_id, agent_name) DO UPDATE SET
                            template = EXCLUDED.template,
                            modified_by = EXCLUDED.modified_by,
                            modified_at = CURRENT_TIMESTAMP,
                            notes = EXCLUDED.notes;
                        
                        GET DIAGNOSTICS repair_count = ROW_COUNT;
                        
                        RETURN QUERY SELECT 
                            'ALL'::VARCHAR(100), 
                            'BULK_REPAIR'::VARCHAR(50), 
                            true, 
                            ('Reparados ' || repair_count || ' prompts')::TEXT;
                    END IF;
                    
                    RETURN;
                END;
                $$ LANGUAGE plpgsql;
                """
                
                cursor.execute(repair_function_sql)
                
                # Crear funciÃ³n create_prompt_version corregida
                version_function_sql = """
                CREATE OR REPLACE FUNCTION create_prompt_version()
                RETURNS TRIGGER AS $$
                DECLARE
                    next_version INTEGER;
                    action_type VARCHAR(50);
                BEGIN
                    -- Determinar el tipo de acciÃ³n
                    IF TG_OP = 'INSERT' THEN
                        action_type := 'CREATE';
                    ELSIF TG_OP = 'UPDATE' THEN
                        action_type := 'UPDATE';
                    ELSE
                        action_type := 'UNKNOWN';
                    END IF;
                    
                    -- Solo proceder si el registro tiene ID (existe en custom_prompts)
                    IF NEW.id IS NOT NULL THEN
                        -- Obtener el siguiente nÃºmero de versiÃ³n para este prompt
                        SELECT COALESCE(MAX(version), 0) + 1 
                        INTO next_version
                        FROM prompt_versions 
                        WHERE prompt_id = NEW.id;
                        
                        -- Insertar nueva versiÃ³n
                        INSERT INTO prompt_versions (
                            prompt_id, company_id, agent_name, template, 
                            version, action, created_by, notes
                        ) VALUES (
                            NEW.id, NEW.company_id, NEW.agent_name, NEW.template,
                            next_version, action_type, NEW.modified_by, 
                            CASE 
                                WHEN action_type = 'CREATE' THEN 'Prompt creado'
                                ELSE 'Prompt actualizado'
                            END
                        );
                    END IF;
                    
                    RETURN NEW;
                END;
                $$ LANGUAGE plpgsql;
                """
                
                cursor.execute(version_function_sql)
                
                # Recrear trigger si no existe
                cursor.execute("""
                    DROP TRIGGER IF EXISTS create_prompt_version_trigger ON custom_prompts;
                    CREATE TRIGGER create_prompt_version_trigger
                        AFTER INSERT OR UPDATE ON custom_prompts
                        FOR EACH ROW EXECUTE FUNCTION create_prompt_version();
                """)
                
                conn.commit()
                logger.info("Funciones SQL reparadas exitosamente")
                return True
                
        except Exception as e:
            logger.error(f"Error reparando funciones SQL: {e}")
            if 'conn' in locals():
                conn.rollback()
            return False
        finally:
            if 'conn' in locals():
                conn.close()
    
    def _fix_foreign_key_constraints(self) -> bool:
        """Arregla problemas de foreign key constraints"""
        logger.info("Arreglando foreign key constraints...")
        
        try:
            conn = psycopg2.connect(self.db_connection_string)
            
            with conn.cursor() as cursor:
                # Limpiar registros huÃ©rfanos en prompt_versions
                cursor.execute("""
                    DELETE FROM prompt_versions 
                    WHERE prompt_id NOT IN (SELECT id FROM custom_prompts)
                """)
                
                orphaned = cursor.rowcount
                if orphaned > 0:
                    logger.info(f"Eliminados {orphaned} registros huÃ©rfanos de prompt_versions")
                
                # Verificar e insertar registros faltantes en custom_prompts para versiones existentes
                cursor.execute("""
                    SELECT DISTINCT pv.company_id, pv.agent_name, pv.template, pv.created_by
                    FROM prompt_versions pv
                    LEFT JOIN custom_prompts cp ON cp.company_id = pv.company_id AND cp.agent_name = pv.agent_name
                    WHERE cp.id IS NULL
                """)
                
                missing_prompts = cursor.fetchall()
                
                for company_id, agent_name, template, created_by in missing_prompts:
                    cursor.execute("""
                        INSERT INTO custom_prompts (company_id, agent_name, template, created_by, modified_by, notes)
                        VALUES (%s, %s, %s, %s, %s, %s)
                        ON CONFLICT (company_id, agent_name) DO NOTHING
                    """, (company_id, agent_name, template, created_by, created_by, "Restaurado por fixer"))
                
                if missing_prompts:
                    logger.info(f"Restaurados {len(missing_prompts)} prompts faltantes")
                
                conn.commit()
                logger.info("Foreign key constraints arreglados")
                return True
                
        except Exception as e:
            logger.error(f"Error arreglando foreign keys: {e}")
            if 'conn' in locals():
                conn.rollback()
            return False
        finally:
            if 'conn' in locals():
                conn.close()
    
    def _migrate_correct_prompts(self) -> bool:
        """Migra los prompts correctos de custom_prompts.json a PostgreSQL"""
        logger.info("Migrando prompts correctos de custom_prompts.json...")
        
        # Buscar archivo custom_prompts.json
        possible_paths = [
            'custom_prompts.json',
            '../custom_prompts.json',
            '../../custom_prompts.json',
            './custom_prompts.json'
        ]
        
        custom_prompts_file = None
        for path in possible_paths:
            if os.path.exists(path):
                custom_prompts_file = path
                break
        
        if not custom_prompts_file:
            logger.error("No se encontrÃ³ custom_prompts.json")
            return False
        
        try:
            # Cargar prompts desde JSON
            with open(custom_prompts_file, 'r', encoding='utf-8') as f:
                custom_prompts = json.load(f)
            
            logger.info(f"Cargado custom_prompts.json desde: {custom_prompts_file}")
            
            conn = psycopg2.connect(self.db_connection_string)
            
            with conn.cursor() as cursor:
                # Limpiar default_prompts existentes
                cursor.execute("DELETE FROM default_prompts")
                
                # Migrar prompts por empresa
                companies_processed = 0
                prompts_migrated = 0
                
                for company_id, agents in custom_prompts.items():
                    if company_id.startswith('_'):  # Skip metadata
                        continue
                    
                    logger.info(f"Procesando empresa: {company_id}")
                    companies_processed += 1
                    
                    for agent_name, agent_data in agents.items():
                        if not isinstance(agent_data, dict):
                            continue
                        
                        default_template = agent_data.get('default_template')
                        if not default_template:
                            continue
                        
                        # Crear descripciÃ³n basada en el agente y empresa
                        description = f"Prompt por defecto para {agent_name} de {company_id}"
                        
                        # Determinar categorÃ­a basada en el nombre del agente
                        category_mapping = {
                            'router_agent': 'routing',
                            'sales_agent': 'sales',
                            'support_agent': 'support',
                            'emergency_agent': 'emergency',
                            'schedule_agent': 'scheduling',
                            'availability_agent': 'availability'
                        }
                        category = category_mapping.get(agent_name, 'general')
                        
                        # Crear clave Ãºnica para agente + empresa
                        unique_agent_name = f"{company_id}_{agent_name}"
                        
                        cursor.execute("""
                            INSERT INTO default_prompts (agent_name, template, description, category)
                            VALUES (%s, %s, %s, %s)
                            ON CONFLICT (agent_name) DO UPDATE SET
                                template = EXCLUDED.template,
                                description = EXCLUDED.description,
                                category = EXCLUDED.category,
                                updated_at = CURRENT_TIMESTAMP
                        """, (unique_agent_name, default_template, description, category))
                        
                        prompts_migrated += 1
                        logger.info(f"Migrado: {unique_agent_name}")
                
                conn.commit()
                logger.info(f"MigraciÃ³n completada: {companies_processed} empresas, {prompts_migrated} prompts")
                return True
                
        except Exception as e:
            logger.error(f"Error migrando prompts: {e}")
            if 'conn' in locals():
                conn.rollback()
            return False
        finally:
            if 'conn' in locals():
                conn.close()
    
    def _validate_system(self) -> bool:
        """Valida que el sistema estÃ© funcionando correctamente"""
        logger.info("Validando sistema...")
        
        try:
            conn = psycopg2.connect(self.db_connection_string, cursor_factory=RealDictCursor)
            
            with conn.cursor() as cursor:
                # Verificar tablas
                cursor.execute("""
                    SELECT table_name FROM information_schema.tables 
                    WHERE table_schema = 'public' 
                    AND table_name IN ('custom_prompts', 'default_prompts', 'prompt_versions')
                """)
                tables = [row['table_name'] for row in cursor.fetchall()]
                
                if len(tables) != 3:
                    logger.error(f"Solo {len(tables)} de 3 tablas encontradas")
                    return False
                
                # Verificar funciones
                cursor.execute("""
                    SELECT routine_name FROM information_schema.routines 
                    WHERE routine_schema = 'public' 
                    AND routine_name IN ('repair_prompts_from_repository', 'create_prompt_version')
                """)
                functions = [row['routine_name'] for row in cursor.fetchall()]
                
                if len(functions) != 2:
                    logger.error(f"Solo {len(functions)} de 2 funciones encontradas")
                    return False
                
                # Contar prompts migrados
                cursor.execute("SELECT COUNT(*) as count FROM default_prompts")
                default_count = cursor.fetchone()['count']
                
                cursor.execute("SELECT COUNT(*) as count FROM custom_prompts")
                custom_count = cursor.fetchone()['count']
                
                cursor.execute("SELECT COUNT(*) as count FROM prompt_versions")
                version_count = cursor.fetchone()['count']
                
                logger.info(f"âœ… Tablas: {len(tables)}/3")
                logger.info(f"âœ… Funciones: {len(functions)}/2")
                logger.info(f"âœ… Default prompts: {default_count}")
                logger.info(f"âœ… Custom prompts: {custom_count}")
                logger.info(f"âœ… Version records: {version_count}")
                
                # Probar funciÃ³n de reparaciÃ³n
                cursor.execute("SELECT * FROM repair_prompts_from_repository('test_company', 'benova_sales_agent')")
                repair_test = cursor.fetchone()
                
                if repair_test:
                    logger.info("âœ… FunciÃ³n de reparaciÃ³n operativa")
                    return True
                else:
                    logger.error("âŒ FunciÃ³n de reparaciÃ³n no funciona")
                    return False
                
        except Exception as e:
            logger.error(f"Error en validaciÃ³n: {e}")
            return False
        finally:
            if 'conn' in locals():
                conn.close()
    
    def get_current_status(self) -> Dict[str, Any]:
        """Obtiene el estado actual del sistema"""
        try:
            conn = psycopg2.connect(self.db_connection_string, cursor_factory=RealDictCursor)
            
            with conn.cursor() as cursor:
                # InformaciÃ³n de tablas
                cursor.execute("SELECT COUNT(*) as count FROM default_prompts")
                default_count = cursor.fetchone()['count']
                
                cursor.execute("SELECT COUNT(*) as count FROM custom_prompts")
                custom_count = cursor.fetchone()['count']
                
                cursor.execute("SELECT COUNT(*) as count FROM prompt_versions")
                version_count = cursor.fetchone()['count']
                
                # Ãšltimos prompts migrados
                cursor.execute("""
                    SELECT agent_name, LEFT(template, 100) as template_preview, updated_at
                    FROM default_prompts 
                    ORDER BY updated_at DESC 
                    LIMIT 5
                """)
                recent_prompts = cursor.fetchall()
                
                return {
                    "tables": {
                        "default_prompts": default_count,
                        "custom_prompts": custom_count,
                        "prompt_versions": version_count
                    },
                    "recent_prompts": [dict(row) for row in recent_prompts],
                    "status": "operational" if default_count > 0 else "needs_migration"
                }
                
        except Exception as e:
            return {"error": str(e), "status": "error"}
        finally:
            if 'conn' in locals():
                conn.close()

def main():
    """FunciÃ³n principal para ejecutar la reparaciÃ³n"""
    if len(sys.argv) > 1 and sys.argv[1] == '--status':
        # Solo mostrar estado actual
        fixer = PromptsSystemFixer()
        status = fixer.get_current_status()
        print(json.dumps(status, indent=2, default=str))
        return
    
    print("ğŸ”§ Iniciando reparaciÃ³n del sistema de prompts multi-tenant")
    print("Este script resolverÃ¡ todos los problemas identificados en Railway\n")
    
    fixer = PromptsSystemFixer()
    
    # Mostrar estado actual
    print("ğŸ“Š Estado actual del sistema:")
    current_status = fixer.get_current_status()
    print(json.dumps(current_status, indent=2, default=str))
    print()
    
    # Ejecutar reparaciÃ³n
    results = fixer.fix_all_issues()
    
    print("\nğŸ¯ Resultados de la reparaciÃ³n:")
    print(json.dumps(results, indent=2, default=str))
    
    if results["success"]:
        print("\nâœ… Â¡ReparaciÃ³n exitosa! El sistema de prompts deberÃ­a funcionar correctamente ahora.")
        print("\nğŸ“ Pasos siguientes:")
        print("1. Reinicia la aplicaciÃ³n en Railway")
        print("2. Verifica que los prompts por defecto sean correctos")
        print("3. Prueba crear/actualizar prompts personalizados")
        print("4. Verifica que la funciÃ³n 'reparar' funcione")
    else:
        print("\nâŒ ReparaciÃ³n fallÃ³. Revisa los errores arriba.")
        return 1
    
    return 0

if __name__ == "__main__":
    exit(main())
